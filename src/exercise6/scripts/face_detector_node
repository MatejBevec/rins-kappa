#!/usr/bin/python3

from typing import Set, Dict, List, Tuple

import rospy
from geometry_msgs.msg import PoseStamped, Vector3, Pose
from sensor_msgs.msg import Image
from visualization_msgs.msg import Marker, MarkerArray
from functools import lru_cache
import math
from std_msgs.msg import ColorRGBA
from cv_bridge import CvBridge
import cv2
import numpy as np
from skimage.measure import label


class FaceLocations:
    def __init__(self):
        self.previous_faces: int = 0
        self.pf_mean: Tuple[float, float] = (0, 0)
        self.markers_pub = rospy.Publisher('confirmed_faces', MarkerArray, queue_size=1000)

        self.valid_faces = set()

        self.waiting_to_approach = False
        self.client = None

        # An object we use for converting images between ROS format and OpenCV format
        self.bridge = CvBridge()
        self.latest_face = None
        self.awaiting_image = False

    def publish_markers(self) -> None:
        marker_array = MarkerArray()
        id = 1
        for face in self.valid_faces:
            pose = Pose()
            pose.position.x = face[0]
            pose.position.y = face[1]
            pose.position.z = 0.29
            id += 1
            marker = Marker()
            marker.header.stamp = rospy.Time(0)
            marker.header.frame_id = 'map'
            marker.pose = pose
            marker.type = Marker.CYLINDER
            marker.action = Marker.ADD
            marker.frame_locked = False
            marker.lifetime = rospy.Duration.from_sec(40) if len(self.valid_faces) < 3 else rospy.Duration.from_sec(200)
            marker.id = id
            marker.scale = Vector3(0.3, 0.3, 0.3)
            marker.color = ColorRGBA(0, 1, 1, 1)
            marker_array.markers.append(marker)
        self.markers_pub.publish(marker_array)

    def check_if_new_markers(self, markers):
        how_many = len(markers)

        newest = markers[-(how_many - self.previous_faces):]
        newest = clean_markers(newest)
        current_mean = get_mean_of_points(newest)

        rospy.loginfo("Got markers! Lemme check 'em ;)")
        if self.previous_faces:
            if are_detections_close(self.pf_mean, current_mean):
                already_done = False
                for face in self.valid_faces:
                    if are_detections_close(face, current_mean):
                        already_done = True
                        break
                if already_done:
                    rospy.loginfo("Found the same again!")
                else:
                    rospy.loginfo("Found a new face!")
                    self.valid_faces.add(current_mean)
                    self.awaiting_image = True
                    print("Known faces:")
                    for i in self.valid_faces:
                        print(i)
                    self.publish_markers()

        self.previous_faces = how_many
        self.pf_mean = current_mean

    def mask_check(self, latest_face):
        dim1, dim2, _ = latest_face.shape
        cutout = latest_face[dim1//2:int(dim1*0.95), :]
        gray = cv2.cvtColor(cutout, cv2.COLOR_BGR2GRAY)
        labels = label(gray)
        size = np.max(np.bincount(labels.flat)[1:])
        if size > 500:
            print(f"MASK DETECTED ({size}). GOOD JOB, PERSON!")
        else:
            print(f"NO MASK ({size}). STAY AWAY.")


def clean_markers(markers: List[Tuple[float, float]]) -> List[Tuple[float, float]]:
    return [point for point in markers if -50 < point[0] < 50]


def are_detections_close(p1: Tuple[float, float], p2: Tuple[float, float], threshold: float = 0.75) -> bool:
    return math.dist(p1, p2) <= threshold


def get_mean_of_points(points: List[Tuple[float, float]]) -> Tuple[float, float]:
    total = [0, 0]
    for i in points:
        total[0] += i[0]
        total[1] += i[1]
    return total[0] / len(points), total[1] / len(points)


@lru_cache()
def get_face_locations():
    rospy.loginfo("Generated and cached the FL class :)")
    return FaceLocations()


def handle_received_face_marker(data):
    fl = get_face_locations()
    fl.check_if_new_markers([(i.pose.position.x, i.pose.position.y) for i in data.markers])


def handle_received_face_image(data):
    fl = get_face_locations()
    if fl.awaiting_image:
        fl.mask_check(fl.bridge.imgmsg_to_cv2(data, "bgr8"))
        fl.awaiting_image = False


if __name__ == '__main__':
    rospy.init_node('face_detector_node')
    get_face_locations.cache_clear()
    get_face_locations()
    rospy.Subscriber('face_markers', MarkerArray, handle_received_face_marker)
    rospy.Subscriber('face_imgs', Image, handle_received_face_image)
    rospy.spin()
